# Подзапросы
https://youtu.be/Xt6OtcI3M4M

## Задание 2
Используя данные из таблицы user_actions, рассчитайте среднее число заказов всех пользователей нашего сервиса.

Для этого сначала в подзапросе посчитайте, сколько заказов сделал каждый пользователь, а затем обратитесь к результату подзапроса в блоке FROM и уже в основном запросе усредните количество заказов по всем пользователям.

Полученное среднее число заказов всех пользователей округлите до двух знаков после запятой. Колонку с этим значением назовите orders_avg.

Поле в результирующей таблице: orders_avg

Решение:

    SELECT
      ROUND(AVG(count_order), 2) AS orders_avg
    FROM
      (
        SELECT
          user_id,
          count(DISTINCT order_id) AS count_order
        FROM
          user_actions
        group by user_id
      ) t1

## Задание 3
Повторите запрос из предыдущего задания, но теперь вместо подзапроса используйте оператор WITH и табличное выражение.

Условия задачи те же: используя данные из таблицы user_actions, рассчитайте среднее число заказов всех пользователей.

Полученное среднее число заказов округлите до двух знаков после запятой. Колонку с этим значением назовите orders_avg.

Поле в результирующей таблице: orders_avg

Решение:

    WITH sub1 AS (
        SELECT
          user_id,
          count(DISTINCT order_id) AS count_order
        FROM
          user_actions
        GROUP BY user_id
    )
    
    SELECT
      ROUND(AVG(count_order), 2) AS orders_avg
    FROM
      sub1 t1

## Задание 4
Выведите из таблицы products информацию о всех товарах кроме самого дешёвого.

Результат отсортируйте по убыванию id товара.

Поля в результирующей таблице: product_id, name, price

Решение:

    SELECT
      product_id,
      name,
      price
    FROM
      products
    WHERE
      price <> (
        SELECT
          MIN(price)
        FROM
          products
      )
    ORDER BY
      product_id DESC

## Задание 5
Выведите информацию о товарах в таблице products, цена на которые превышает среднюю цену всех товаров на 20 рублей и более. Результат отсортируйте по убыванию id товара.

Поля в результирующей таблице: product_id, name, price

Решение:

    WITH sub1 AS (
      SELECT
        ROUND(AVG(price), 2) as avg_price
      FROM
        products
    )
    SELECT
      product_id,
      name,
      price
    FROM
      products
    WHERE
      price >= (
        SELECT
          *
        FROM
          sub1
      ) + 20
    ORDER BY
      product_id DESC

## Задание 6
Посчитайте количество уникальных клиентов в таблице user_actions, сделавших за последнюю неделю хотя бы один заказ.

Полученную колонку с числом клиентов назовите users_count. В качестве текущей даты, от которой откладывать неделю, используйте последнюю дату в той же таблице user_actions.

Поле в результирующей таблице: users_count

Решение:

    SELECT
      count(distinct user_id) as users_count
    FROM
      user_actions
    WHERE
      action = 'create_order'
      and time >= (
        SELECT
          max(time)
        FROM
          user_actions
      ) - interval '1 week'

## Задание 7
С помощью функции AGE и агрегирующей функции снова определите возраст самого молодого курьера мужского пола в таблице couriers, но в этот раз при расчётах в качестве первой даты используйте последнюю дату из таблицы courier_actions.

Чтобы получить именно дату, перед применением функции AGE переведите последнюю дату из таблицы courier_actions в формат DATE, как мы делали в этом задании.

Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип VARCHAR. Полученную колонку со значением возраста назовите min_age.

Поле в результирующей таблице: min_age

Пояснение:

В этой задаче результат подзапроса выступает в качестве аргумента функции. Чтобы весь запрос выглядел компактнее, для приведения данных к другому типу можно использовать формат записи с двумя двоеточиями — ::.

Также обратите внимание, что для получения необходимого результата мы обращаемся к разным таблицам в рамках одного общего запроса.

Решение:

    SELECT
      min(
        age(
          (
            SELECT
              max(time) :: date
            FROM
              courier_actions
          ),
          birth_date
        )
      ) :: varchar as min_age
    FROM
      couriers
    WHERE
      sex = 'male'

## Задание 8
Из таблицы user_actions с помощью подзапроса или табличного выражения отберите все заказы, которые не были отменены пользователями.

Выведите колонку с id этих заказов. Результат запроса отсортируйте по возрастанию id заказа.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поле в результирующей таблице: order_id

Подсказка:

Сначала в подзапросе попробуйте отобрать множество id заказов, которые были отменены. Затем уже в рамках основного запроса с помощью WHERE и IN отфильтруйте id отменённых заказов.

Решение:

    SELECT
      order_id
    FROM
      user_actions
    WHERE
      order_id NOT IN (
        SELECT
          order_id
        FROM
          user_actions
        WHERE
          action = 'cancel_order'
      )
    ORDER BY
      order_id ASC
    LIMIT
      1000

## Задание 9
Используя данные из таблицы user_actions, рассчитайте, сколько заказов сделал каждый пользователь и отразите это в столбце orders_count.

В отдельном столбце orders_avg напротив каждого пользователя укажите среднее число заказов всех пользователей, округлив его до двух знаков после запятой.

Также для каждого пользователя посчитайте отклонение числа заказов от среднего значения. Отклонение считайте так: число заказов «минус» округлённое среднее значение. Колонку с отклонением назовите orders_diff.

Результат отсортируйте по возрастанию id пользователя. Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: user_id, orders_count, orders_avg, orders_diff

Решение:

    WITH avg_order_user AS(
      SELECT
        ROUND(count(DISTINCT order_id) / count(DISTINCT user_id) :: decimal, 2) AS avg_order
      FROM
        user_actions
    )
    
    SELECT
      user_id,
      COUNT(DISTINCT order_id) AS orders_count,
      (
        SELECT
          avg_order
        FROM
          avg_order_user
      ) AS orders_avg,
      COUNT(DISTINCT order_id) - (
        SELECT
          avg_order
        FROM
          avg_order_user
      ) AS orders_diff
    FROM
      user_actions
    GROUP BY
      user_id
    ORDER BY
      user_id
    LIMIT
      1000

## Задание 10
Назначьте скидку 15% на товары, цена которых превышает среднюю цену на все товары на 50 и более рублей, а также скидку 10% на товары, цена которых ниже средней на 50 и более рублей. Цену остальных товаров внутри диапазона (среднее - 50; среднее + 50) оставьте без изменений. При расчёте средней цены, округлите её до двух знаков после запятой.

Выведите информацию о всех товарах с указанием старой и новой цены. Колонку с новой ценой назовите new_price.

Результат отсортируйте сначала по убыванию прежней цены в колонке price, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, new_price

Пояснение:

Чтобы не пришлось дважды писать один и тот же подзапрос, рекомендуем в этой задаче использовать оператор WITH.

Решение:

    SELECT
      product_id,
      name,
      price,
      CASE
        WHEN price::DECIMAL - (SELECT * FROM avg_price) > 50 THEN price * (1 - 0.15)
        WHEN price::DECIMAL - (SELECT * FROM avg_price) < -50 THEN price * (1 - 0.10)
        ELSE price
      END AS new_price
    FROM
      products
    ORDER BY
      price DESC,
      product_id ASC

## Задание 11
Выясните, есть ли в таблице courier_actions такие заказы, которые были приняты курьерами, но не были созданы пользователями. Посчитайте количество таких заказов.

Колонку с числом заказов назовите orders_count.

Поле в результирующей таблице: orders_count

Решение:

    SELECT
      count(distinct order_id) as orders_count
    FROM
      courier_actions
    WHERE
      order_id not in (
        SELECT
          order_id
        FROM
          user_actions
      )

## Задание 12
Выясните, есть ли в таблице courier_actions такие заказы, которые были приняты курьерами, но не были доставлены пользователям. Посчитайте количество таких заказов.

Колонку с числом заказов назовите orders_count.

Поле в результирующей таблице: orders_count

Решение:

    SELECT
      COUNT(DISTINCT order_id) AS orders_count
    FROM
      courier_actions
    WHERE
      action = 'accept_order'
      AND order_id NOT IN (
        SELECT
          order_id
        FROM
          courier_actions
        WHERE
          action = 'deliver_order'
      )

## Задание 13
Определите количество отменённых заказов в таблице courier_actions и выясните, есть ли в этой таблице такие заказы, которые были отменены пользователями, но при этом всё равно были доставлены. Посчитайте количество таких заказов.

Колонку с отменёнными заказами назовите orders_canceled. Колонку с отменёнными, но доставленными заказами назовите orders_canceled_and_delivered. 

Поля в результирующей таблице: orders_canceled, orders_canceled_and_delivered

Пояснение:

Для решения задачи пригодится оператор FILTER, который мы рассматривали в [этом уроке](../sql-karpov/1_5.md#задание-16).

Решение:

Вариант 1

    WITH cancel_orders AS(
      SELECT
        order_id AS order_id
      FROM
        user_actions
      WHERE
        action = 'cancel_order'
    )
    SELECT
      count(DISTINCT order_id) FILTER (
        WHERE
          order_id IN (
            SELECT
              order_id
            FROM
              cancel_orders
          )
      ) AS orders_canceled,
      count(DISTINCT order_id) FILTER (
        WHERE
          order_id IN (
            SELECT
              order_id
            FROM
              cancel_orders
          )
          AND action = 'deliver_order'
      ) AS orders_canceled_and_delivered
    FROM
      courier_actions

Вариант 2

    SELECT
      count(distinct order_id) as orders_canceled,
      count(order_id) filter (
        WHERE
          action = 'deliver_order'
      ) as orders_canceled_and_delivered
    FROM
      courier_actions
    WHERE
      order_id in (
        SELECT
          order_id
        FROM
          user_actions
        WHERE
          action = 'cancel_order'
      )

## Задание 14
По таблицам courier_actions и user_actions снова определите число недоставленных заказов и среди них посчитайте количество отменённых заказов и количество заказов, которые не были отменены (и соответственно, пока ещё не были доставлены).

Колонку с недоставленными заказами назовите orders_undelivered, колонку с отменёнными заказами назовите orders_canceled, колонку с заказами «в пути» назовите orders_in_process.

Поля в результирующей таблице: orders_undelivered, orders_canceled, orders_in_process

Пояснение:

Для решения задачи пригодится оператор FILTER, который мы рассматривали в этом уроке.

На заметку:

Подзапросы можно также использовать и в операторе FILTER для формирования ещё более продвинутых условий фильтрации. В таком случае конструкция будет иметь следующий вид:

    SELECT COUNT(column) FILTER (WHERE column > (SELECT AVG(column) FROM table)) AS count
    FROM table


Такой запрос посчитает количество значений в колонке column, которые превышают среднее значение по этой же колонке. Разумеется, в подзапросе, указанном в FILTER, можно обращаться и к другим колонкам и таблицам, применяя любые другие способы фильтрации — например, оператор IN:

    SELECT COUNT(column_1) FILTER (WHERE column_1 IN (SELECT column_2 FROM table_2)) AS count
    FROM table_1


Для решения этой задачи использовать подзапросы в операторе FILTER не обязательно, но попробовать можно.

Решение:

Вариант 1

    SELECT
      COUNT(DISTINCT order_id) as orders_undelivered,
      COUNT(DISTINCT order_id) FILTER (
        WHERE
          order_id IN (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
      ) AS orders_canceled,
      COUNT(DISTINCT order_id) FILTER (
        WHERE
          order_id NOT IN (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
          and action <> 'deliver_order'
      ) as orders_in_process
    FROM
      courier_actions
    WHERE
      action = 'accept_order'
      AND order_id NOT IN (
        SELECT
          order_id
        FROM
          courier_actions
        WHERE
          action = 'deliver_order'
      )

Вариант 2

    SELECT
      count(distinct order_id) as orders_undelivered,
      count(order_id) filter (
        WHERE
          action = 'cancel_order'
      ) as orders_canceled,
      count(distinct order_id) - count(order_id) filter (
        WHERE
          action = 'cancel_order'
      ) as orders_in_process
    FROM
      user_actions
    WHERE
      order_id in (
        SELECT
          order_id
        FROM
          courier_actions
        WHERE
          order_id not in (
            SELECT
              order_id
            FROM
              courier_actions
            WHERE
              action = 'deliver_order'
          )
      )
