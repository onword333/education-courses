# JOIN - основные типы объединений
## Задание 1
Объедините таблицы user_actions и users по ключу user_id. В результат включите две колонки с user_id из обеих таблиц. Эти две колонки назовите соответственно user_id_left и user_id_right. Также в результат включите колонки order_id, time, action, sex, birth_date. Отсортируйте получившуюся таблицу по возрастанию id пользователя (в любой из двух колонок с id).

Поля в результирующей таблице: user_id_left, user_id_right,  order_id, time, action, sex, birth_date

Пояснение:

Обратите внимание, что в результате объединения колонки с ключами (в нашем случае это user_id) не превращаются в одну общую колонку, а вместе добавляются в результирующую таблицу. То есть сколько было суммарно колонок в двух таблицах, столько окажется и в результирующей таблице после объединения. А уже далее в операторе SELECT можно выбирать нужные и проводить над ними операции.

Чтобы обратиться к колонкам с одинаковым именем (user_id), пришедшим из разных таблиц, назначьте таблицам алиасы и обратитесь к колонкам через них. Пример, как это можно сделать:

    SELECT A.id as id_a, 
           B.id as id_b, 
           ...
    FROM table_A as A
         JOIN table_B as B
         ON A.id = B.id
    ...

После того как решите задачу, обратите внимание на колонки с user_id. Все ли значения в них попарно совпадают?

Решение:

    SELECT
      ua.user_id AS user_id_left,
      u.user_id AS user_id_right,
      ua.order_id AS order_id,
      ua.time AS time,
      ua.action AS action,
      u.sex AS sex,
      u.birth_date AS birth_date
    FROM
      user_actions ua
      INNER JOIN users u ON ua.user_id = u.user_id
    ORDER BY
      u.user_id

## Задание 2
А теперь попробуйте немного переписать запрос из прошлого задания и посчитать количество уникальных id в объединённой таблице. То есть снова объедините таблицы, но в этот раз просто посчитайте уникальные user_id в одной из колонок с id. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите users_count.

Поле в результирующей таблице: users_count

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах users и user_actions, которое мы посчитали на прошлом шаге. С каким значением оно совпадает ?

Решение:

    SELECT
      COUNT(DISTINCT ua.user_id) AS users_count
    FROM
      user_actions ua
      INNER JOIN users u ON ua.user_id = u.user_id

## Задание 3
С помощью LEFT JOIN объедините таблицы user_actions и users по ключу user_id. Обратите внимание на порядок таблиц — слева users_actions, справа users. В результат включите две колонки с user_id из обеих таблиц. Эти две колонки назовите соответственно user_id_left и user_id_right. Также в результат включите колонки order_id, time, action, sex, birth_date. Отсортируйте получившуюся таблицу по возрастанию id пользователя (в колонке из левой таблицы).

Поля в результирующей таблице: user_id_left, user_id_right,  order_id, time, action, sex, birth_date

После того как решите задачу, обратите внимание на колонки с user_id. Нет ли в какой-то из них пропущенных значений?

Решение:

    SELECT
      ua.user_id AS user_id_left,
      u.user_id AS user_id_right,
      ua.order_id AS order_id,
      ua.time AS time,
      ua.action AS action,
      u.sex AS sex,
      u.birth_date AS birth_date
    FROM
      user_actions ua
      LEFT JOIN users u ON ua.user_id = u.user_id
    ORDER BY
      ua.user_id

## Задание 4
Теперь снова попробуйте немного переписать запрос из прошлого задания и посчитайте количество уникальных id в колонке user_id, пришедшей из левой таблицы user_actions. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите users_count.

Поле в результирующей таблице: users_count

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах users и user_actions. С каким значением оно совпало в этот раз?

Решение:

    SELECT
      COUNT(DISTINCT ua.user_id) AS users_count
    FROM
      user_actions ua
      LEFT JOIN users u ON ua.user_id = u.user_id

## Задание 5
Возьмите запрос из задания 3, где вы объединяли таблицы user_actions и users с помощью LEFT JOIN, добавьте к запросу оператор WHERE и исключите NULL значения в колонке user_id из правой таблицы. Включите в результат все те же колонки и отсортируйте получившуюся таблицу по возрастанию id пользователя в колонке из левой таблицы.

Поля в результирующей таблице: user_id_left, user_id_right,  order_id, time, action, sex, birth_date

После того как решите задачу, попробуйте сдать это же решение в первом задании — сработает или нет? Подумайте, какой JOIN мы сейчас получили после всех манипуляций с результатом. Заодно можете посчитать число уникальных user_id в запросе из этого задания, чтобы расставить все точки над «i».

Решение:

    SELECT
      ua.user_id AS user_id_left,
      u.user_id AS user_id_right,
      ua.order_id AS order_id,
      ua.time AS time,
      ua.action AS action,
      u.sex AS sex,
      u.birth_date AS birth_date
    FROM
      user_actions ua
      LEFT JOIN users u ON ua.user_id = u.user_id
    WHERE
      u.user_id IS NOT NULL
    ORDER BY
      ua.user_id

## Задание 6
С помощью FULL JOIN объедините по ключу birth_date таблицы, полученные в результате вышеуказанных запросов (то есть объедините друг с другом два подзапроса). Не нужно изменять их, просто добавьте нужный JOIN.

В результат включите две колонки с birth_date из обеих таблиц. Эти две колонки назовите соответственно users_birth_date и couriers_birth_date. Также включите в результат колонки с числом пользователей и курьеров — users_count и couriers_count.

Отсортируйте получившуюся таблицу сначала по колонке users_birth_date по возрастанию, затем по колонке couriers_birth_date — тоже по возрастанию.

Поля в результирующей таблице: users_birth_date, users_count,  couriers_birth_date, couriers_count

После того как решите задачу, изучите полученную таблицу в Redash. Обратите внимание на пропущенные значения в колонках с датами рождения курьеров и пользователей. Подтвердилось ли наше предположение?

Решение:

Вариант 1

    WITH users_birth_date AS (
      SELECT
        birth_date,
        COUNT(user_id) AS users_count
      FROM
        users
      WHERE
        birth_date IS NOT NULL
      GROUP BY
        birth_date
    ),
    couriers_birth_date AS (
      SELECT
        birth_date,
        COUNT(courier_id) AS couriers_count
      FROM
        couriers
      WHERE
        birth_date IS NOT NULL
      GROUP BY
        birth_date
    )
    
    SELECT
      c.birth_date AS couriers_birth_date,
      u.birth_date AS users_birth_date,
      SUM(c.couriers_count) AS couriers_count,
      SUM(u.users_count) AS users_count
    FROM
      couriers_birth_date c FULL
      JOIN users_birth_date u ON c.birth_date = u.birth_date
    GROUP BY
      c.birth_date,
      u.birth_date
    ORDER BY
      u.birth_date,
      c.birth_date

Вариант 2

    SELECT
      a.birth_date as users_birth_date,
      users_count,
      b.birth_date as couriers_birth_date,
      couriers_count
    FROM
      (
        SELECT
          birth_date,
          count(user_id) as users_count
        FROM
          users
        WHERE
          birth_date is not null
        GROUP BY
          birth_date
      ) a full
      join (
        SELECT
          birth_date,
          count(courier_id) as couriers_count
        FROM
          couriers
        WHERE
          birth_date is not null
        GROUP BY
          birth_date
      ) b using(birth_date)
    ORDER BY
      users_birth_date,
      couriers_birth_date

## Задание 7
Объедините два следующих запроса друг с другом так, чтобы на выходе получился набор уникальных дат из таблиц users и couriers:

    SELECT birth_date
    FROM users
    WHERE birth_date IS NOT NULL
    
    
    SELECT birth_date
    FROM couriers
    WHERE birth_date IS NOT NULL

Поместите в подзапрос полученный после объединения набор дат и посчитайте их количество. Колонку с числом дат назовите dates_count.

Поле в результирующей таблице: dates_count

После того как решите задачу, сравните полученное число дат с количеством строк в таблице, которую мы получили в прошлом задании. Совпали ли эти значения?

Решение:

    SELECT
      COUNT(birth_date) AS dates_count
    FROM
      (
        SELECT
          birth_date
        FROM
          users
        WHERE
          birth_date IS NOT NULL
        UNION
        SELECT
          birth_date
        FROM
          couriers
        WHERE
          birth_date IS NOT NULL
      ) t

## Задание 8
Из таблицы users отберите id первых 100 пользователей (просто выберите первые 100 записей, используя простой LIMIT) и с помощью CROSS JOIN объедините их со всеми наименованиями товаров из таблицы products. Выведите две колонки — id пользователя и наименование товара. Результат отсортируйте сначала по возрастанию id пользователя, затем по имени товара — тоже по возрастанию.

Поля в результирующей таблице: user_id, name

После того как решите задачу, посмотрите сколько было изначально строк в каждой таблице и сравните с тем, сколько их получилось после объединения.

Решение:

    SELECT
      name,
      u.user_id
    FROM
      products
      CROSS JOIN (
        SELECT
          user_id
        FROM
          users
        LIMIT
          100
      ) u
    ORDER BY
      u.user_id,
      name

## Задание 9
Для начала объедините таблицы user_actions и orders — это вы уже умеете делать. В качестве ключа используйте поле order_id. Выведите id пользователей и заказов, а также список товаров в заказе. Отсортируйте таблицу по id пользователя по возрастанию, затем по id заказа — тоже по возрастанию.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: user_id, order_id, product_ids

Пояснение:

Перед тем как объединять таблицы, подумайте, какой тип соединения можно использовать. Попробуйте разные способы и сравните результаты.

Решение:

    SELECT
      user_id,
      order_id,
      product_ids
    FROM
      user_actions
      LEFT JOIN orders using(order_id)
    ORDER BY
      user_id,
      order_id
    LIMIT
      1000

## Задание 10
Задание:

Снова объедините таблицы user_actions и orders, но теперь оставьте только уникальные неотменённые заказы (мы делали похожий запрос на прошлом уроке). Остальные условия задачи те же: вывести id пользователей и заказов, а также список товаров в заказе. Отсортируйте таблицу по id пользователя по возрастанию, затем по id заказа — тоже по возрастанию.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: user_id, order_id, product_ids

Пояснение:

Обратите внимание, что отфильтровать значения вы можете двумя способами. Это можно сделать либо до объединения таблиц, либо после него. Рекомендуется делать фильтрацию до объединения, так как в таком случае вы заранее уменьшаете количество строк в одной из таблиц и тем самым ускоряете процесс объединения. Однако для этого потребуется написать вложенный запрос.

Решение:

    SELECT
      ua.user_id,
      ua.order_id,
      o.product_ids
    FROM
      (
        SELECT
          user_id,
          order_id
        FROM
          user_actions
        WHERE
          order_id NOT IN (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
      ) ua
      LEFT JOIN orders o ON ua.order_id = o.order_id
    ORDER BY
      ua.user_id,
      ua.order_id
    LIMIT
      1000

## Задание 11
Используя запрос из предыдущего задания, посчитайте, сколько в среднем товаров заказывает каждый пользователь. Выведите id пользователя и среднее количество товаров в заказе. Среднее значение округлите до двух знаков после запятой. Колонку посчитанными значениями назовите avg_order_size. Результат выполнения запроса отсортируйте по возрастанию id пользователя. 

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: user_id, avg_order_size

Пояснение:

Для решения вам пригодится функция array_length. Мы рассматривали её в [этом задании](./1_5.md#задание-9)

Решение:

    SELECT
      ua.user_id,      
      ROUND(AVG(array_length(o.product_ids, 1)), 2) AS avg_order_size
    FROM
      (
        SELECT
          user_id,
          order_id
        FROM
          user_actions
        WHERE
          order_id NOT IN (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
      ) ua
      LEFT JOIN orders o ON ua.order_id = o.order_id
    GROUP BY
      ua.user_id
    ORDER BY
      ua.user_id
    LIMIT
      1000

## Задание 12

Для начала к таблице с заказами (orders) примените функцию unnest, как мы делали в прошлом уроке. Колонку с id товаров назовите product_id. Затем к образовавшейся расширенной таблице по ключу product_id добавьте информацию о ценах на товары (из таблицы products). Должна получиться таблица с заказами, товарами внутри каждого заказа и ценами на эти товары. Выведите колонки с id заказа, id товара и ценой товара. Результат отсортируйте сначала по возрастанию id заказа, затем по возрастанию id товара.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: order_id, product_id, price

Решение:

    SELECT
      o.order_id,
      o.product_id,
      p.price
    FROM
      (
        SELECT
          order_id,
          UNNEST(product_ids) AS product_id
        FROM
          orders
      ) o
      LEFT JOIN products p ON o.product_id = p.product_id
    ORDER BY
      o.order_id,
      o.product_id
    LIMIT
      1000


## Задание 13
Используя запрос из предыдущего задания, рассчитайте суммарную стоимость каждого заказа. Выведите колонки с id заказов и их стоимостью. Колонку со стоимостью заказа назовите order_price. Результат отсортируйте по возрастанию id заказа.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: order_id, order_price

Решение:

    SELECT
      o.order_id,      
      SUM(p.price) AS order_price
    FROM
      (
        SELECT
          order_id,
          UNNEST(product_ids) AS product_id
        FROM
          orders
      ) o
      LEFT JOIN products p ON o.product_id = p.product_id
    GROUP BY
      o.order_id
    ORDER BY
      o.order_id
    LIMIT
      1000
