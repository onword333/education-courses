# Агрегация данных

## Задание 1
Выведите id всех уникальных пользователей из таблицы user_actions. Результат отсортируйте по возрастанию id.

Поле в результирующей таблице: user_id

Решение:

    SELECT
        DISTINCT user_id
    FROM user_actions
    ORDER BY
    user_id ASC

## Задание 2
Примените DISTINCT сразу к двум колонкам таблицы courier_actions и отберите уникальные пары значений courier_id и order_id.

Результат отсортируйте сначала по возрастанию id курьера, затем по возрастанию id заказа.

Поля в результирующей таблице: courier_id, order_id

Решение:

    SELECT DISTINCT 
      courier_id, 
      order_id
    FROM courier_actions
    ORDER BY
        courier_id ASC,
        order_id ASC

## Задание 3
Посчитайте максимальную и минимальную цены товаров в таблице products. Поля назовите соответственно max_price, min_price.

Поля в результирующей таблице: max_price, min_price

Пояснение:

В одном запросе можно использовать сразу несколько агрегирующих функций — если необходимо, то даже по нескольким разным колонкам.

Решение:

    SELECT
        MIN(price) AS min_price,
        MAX(price) AS max_price
    FROM products

## Задание 4
Как вы помните, в таблице users у некоторых пользователей не были указаны их даты рождения.

Посчитайте в одном запросе количество всех записей в таблице и количество только тех записей, для которых в колонке birth_date указана дата рождения.

Колонку с общим числом записей назовите dates, а колонку с записями без пропусков — dates_not_null.

Поля в результирующей таблице: dates, dates_not_null

Решение:

    SELECT
        COUNT(*) AS dates, 
        COUNT(birth_date) AS dates_not_null
    FROM users

## Задание 5
Посчитайте количество всех значений в колонке user_id в таблице user_actions, а также количество уникальных значений в этой колонке (т.е. количество уникальных пользователей сервиса).

Колонку с первым полученным значением назовите users, а колонку со вторым — unique_users.

Поля в результирующей таблице: users, unique_users

Решение:

    SELECT
        COUNT(user_id) AS users, 
        COUNT(DISTINCT user_id) AS unique_users
    FROM user_actions

## Задание 6
Посчитайте количество курьеров женского пола в таблице couriers. Полученный столбец с одним значением назовите couriers.

Поле в результирующей таблице: couriers

Решение:

    SELECT
        COUNT(courier_id) AS couriers
    FROM couriers
    WHERE sex = 'female'

## Задание 7
Рассчитайте время, когда были совершены первая и последняя доставки заказов в таблице courier_actions.

Колонку с временем первой доставки назовите first_delivery, а колонку с временем последней — last_delivery.

Поля в результирующей таблице: first_delivery, last_delivery

Пояснение:

Обратите внимание, что в таблице с действиями курьеров есть не только записи с временем доставки заказов, но и записи с временем их принятия. 

Решение:

    SELECT
        MIN(time) AS first_delivery, 
        MAX(time) AS last_delivery
    FROM courier_actions
    WHERE action = 'deliver_order'

## Задание 8

Представьте, что один из пользователей сервиса сделал заказ, в который вошли одна пачка сухариков, одна пачка чипсов и один энергетический напиток. Посчитайте стоимость такого заказа.

Колонку с рассчитанной стоимостью заказа назовите order_price.

Для расчётов используйте таблицу products.

Поле в результирующей таблице: order_price

Решение:

    SELECT
        SUM(price) AS order_price
    FROM products
    WHERE 
        name in('сухарики', 'чипсы', 'энергетический напиток')

## Задание 9
Посчитайте количество заказов в таблице orders с девятью и более товарами. Для этого воспользуйтесь функцией array_length, отфильтруйте данные по количеству товаров в заказе и проведите агрегацию. Полученный столбец назовите orders.

Поле в результирующей таблице: orders

Пояснение:

В наших данных в колонке product_ids содержатся обычные списки товаров всего с одной размерностью

Решение:

    SELECT
        COUNT(order_id) as orders
    FROM orders
    WHERE 
        array_length(product_ids, 1) >= 9

## Задание 10
С помощью функции AGE и агрегирующей функции рассчитайте возраст самого молодого курьера мужского пола в таблице couriers.

Возраст выразите количеством лет, месяцев и дней (как в примере выше), переведя его в тип VARCHAR. 

В качестве даты, относительно которой считать возраст курьеров, используйте свою текущую дату (либо не указывайте её на месте первого аргумента, как показано в примерах).

Полученную колонку со значением возраста назовите min_age.

Поле в результирующей таблице: min_age

Пояснение:

Поскольку в качестве даты, относительно которой производится расчёт возраста, мы используем текущую дату, каждый новый день мы будем получать новый результат. Иными словами, курьеры будут стареть вместе с нашим курсом.

Разумеется, считать возраст таким образом не совсем корректно. Мы научимся делать это правильно в уроке «Подзапросы».

В качестве ожидаемого результата представлено не конкретное значение возраста, а результат в общем виде.

 Ожидаемый результат

Решение:

    SELECT
        MIN(AGE(current_date, birth_date))::varchar AS min_age
    FROM couriers
    where sex = 'male'

## Задание 11
Посчитайте стоимость заказа, в котором будут три пачки сухариков, две пачки чипсов и один энергетический напиток. Колонку с рассчитанной стоимостью заказа назовите order_price.

Для расчётов используйте таблицу products.

Поле в результирующей таблице: order_price

Решение:

    SELECT
      SUM(
        CASE
          WHEN name = 'сухарики' THEN price * 3
          WHEN name = 'чипсы' THEN price * 2
          WHEN name = 'энергетический напиток' THEN price
          ELSE 0
        END
      ) AS order_price
    FROM
      products
    WHERE
      name in('сухарики', 'чипсы', 'энергетический напиток')

## Задание 12
Рассчитайте среднюю цену товаров в таблице products, в названиях которых присутствуют слова «чай» или «кофе». Любым известным способом исключите из расчёта товары содержащие «иван-чай» или «чайный гриб».

Среднюю цену округлите до двух знаков после запятой. Столбец с полученным значением назовите avg_price.

Поле в результирующей таблице: avg_price

Пояснение:

Помните, что порядком выполнения логических выражений можно управлять с помощью скобок. Это может пригодиться.

Решение:

    SELECT
      ROUND(AVG(price), 2) AS avg_price
    FROM
      products
    WHERE
      (
        name LIKE '%чай%'
        OR name LIKE '%кофе%'
      )
      AND (
        name NOT LIKE '%иван-чай%'
        AND name NOT LIKE '%чайный гриб%'
      )

## Задание 13
Воспользуйтесь функцией AGE и рассчитайте разницу в возрасте между самым старым и самым молодым пользователями мужского пола в таблице users. 

Разницу в возрасте выразите количеством лет, месяцев и дней, переведя её в тип VARCHAR. 

Колонку с посчитанным значением назовите age_diff.

Поле в результирующей таблице: age_diff

Решение:

    SELECT
      AGE(max(birth_date), min(birth_date)) :: varchar as age_diff
    FROM
      users
    WHERE
      sex = 'male'

## Задание 14
Рассчитайте среднее количество товаров в заказах из таблицы orders, которые пользователи оформляли по выходным дням (суббота и воскресенье) в течение всего времени работы сервиса.

Полученное значение округлите до двух знаков после запятой. Колонку с ним назовите avg_order_size.

Поле в результирующей таблице: avg_order_size

Результат:

    SELECT
      ROUND(AVG(array_length(product_ids, 1)), 2) AS avg_order_size
    FROM
      orders
    WHERE
      DATE_PART('dow', creation_time) = 0
      OR DATE_PART('dow', creation_time) = 6

## Задание 15
На основе данных в таблице user_actions посчитайте количество уникальных пользователей сервиса, количество уникальных заказов, поделите одно на другое и выясните, сколько заказов приходится на одного пользователя.

В результирующей таблице отразите все три значения — поля назовите соответственно unique_users, unique_orders, orders_per_user.

Показатель числа заказов на пользователя округлите до двух знаков после запятой.

Поля в результирующей таблице: unique_users, unique_orders, orders_per_user

Пояснение:

Важно: чтобы получить корректный результат деления, необходимо хотя бы одно из значений предварительно привести к типу DECIMAL. Иначе результатом деления целого числа на другое целое число будет тоже целое число.

Кстати, с подобной проблемой можно ознакомиться на stackoverflow. Это крайне полезный ресурс для поиска ответов на свои вопросы. Даже опытные программисты часто им пользуются. Можете уже сейчас начать вырабатывать привычку обращаться к нему в случае возникновения проблем.

Также помните, что использовать в расчётах алиасы новых колонок нельзя.

Решение:

    SELECT
      COUNT(DISTINCT user_id) AS unique_users,
      COUNT(DISTINCT order_id) AS unique_orders,
      ROUND(
        COUNT(DISTINCT order_id) :: decimal / COUNT(DISTINCT user_id),
        2
      ) AS orders_per_user
    FROM
      user_actions

## Задание 16
Посчитайте, сколько пользователей никогда не отменяли свой заказ. Для этого из общего числа всех уникальных пользователей отнимите число уникальных пользователей, которые хотя бы раз отменяли заказ. Подумайте, какое условие необходимо указать в FILTER, чтобы получить корректный результат.

Полученный столбец назовите users_count.

Поле в результирующей таблице: users_count

Решение:

    SELECT
      COUNT(DISTINCT user_id) FILTER(
        WHERE
          action = 'create_order'
      ) - COUNT(DISTINCT user_id) FILTER(
        WHERE
          action = 'cancel_order'
      ) as users_count,
    FROM
      user_actions

## Задание 17
Посчитайте общее количество заказов в таблице orders, количество заказов с пятью и более товарами и найдите долю заказов с пятью и более товарами в общем количестве заказов.

В результирующей таблице отразите все три значения — поля назовите соответственно orders, large_orders, large_orders_share.

Долю заказов с пятью и более товарами в общем количестве товаров округлите до двух знаков после запятой.

Поля в результирующей таблице: orders, large_orders, large_orders_share

Решение:

    SELECT
      COUNT(order_id) as orders,
      COUNT(order_id) FILTER(
        WHERE
          array_length(product_ids, 1) >= 5
      ) as large_orders,
      ROUND(
        COUNT(order_id) FILTER(
          WHERE
            array_length(product_ids, 1) >= 5
        ) :: decimal / COUNT(order_id),
        2
      ) AS large_orders_share
    FROM
      orders

## Подведем итоги
В этом уроке мы:

- Познакомились с ключевым словом DISTINCT.
- Разобрались, как работают агрегирующие функции SUM, MIN, MAX, COUNT.
- Узнали разницу между COUNT(*) и COUNT(column).
- Научились совмещать фильтрацию и агрегацию в одном запросе.
- Поработали с массивами и узнали, что делает функция array_length.
- Узнали ещё больше про даты и время и познакомились с функцией AGE.
- Затронули более продвинутую тему — агрегатные выражения с фильтрацией.
- Известные нам на текущий момент ключевые слова и порядок их написания в запросе:

        SELECT     -- перечисление полей результирующей таблицы
        FROM       -- указание источника данных
        WHERE      -- фильтрация данных
        ORDER BY   -- сортировка результирующей таблицы
        LIMIT      -- ограничение количества выводимых записей
