# Анализ продуктовых метрик. Экономика продукта

## Задание 1
Начнём с выручки — наиболее общего показателя, который покажет, какой доход приносит наш сервис.

Для каждого дня в таблице orders рассчитайте следующие показатели:

1. Выручку, полученную в этот день.
2. Суммарную выручку на текущий день.
3. Прирост выручки, полученной в этот день, относительно значения выручки за предыдущий день.

Колонки с показателями назовите соответственно revenue, total_revenue, revenue_change. Колонку с датами назовите date.

Прирост выручки рассчитайте в процентах и округлите значения до двух знаков после запятой.

Результат должен быть отсортирован по возрастанию даты.

Поля в результирующей таблице: date, revenue, total_revenue, revenue_change

**Пояснение:**

Будем считать, что оплата за заказ поступает сразу же после его оформления, т.е. случаи, когда заказ был оформлен в один день, а оплата получена на следующий, возникнуть не могут.

Суммарная выручка на текущий день — это результат сложения выручки, полученной в текущий день, со значениями аналогичного показателя всех предыдущих дней.

При расчёте выручки помните, что не все заказы были оплачены — некоторые были отменены пользователями.

Не забывайте при делении заранее приводить значения к нужному типу данных. Пропущенные значения прироста для самой первой даты не заполняйте — просто оставьте поля в этой строке пустыми.

**Подсказка на случай, если совсем не получается**

Для решения задачи вам потребуется информация о заказах из таблицы orders и ценах на товары из таблицы products. Чтобы посчитать выручку для каждого дня, сначала необходимо посчитать стоимость каждого заказа. Это можно сделать, сложив цены входящих в заказ товаров. Чтобы правильно присоединить данные о ценах на товары, списки с содержимым заказов нужно предварительно расширить с помощью функции unnest. После того как для каждого дня будет посчитана суммарная стоимость всех заказов (выручка), с помощью оконных функций можно посчитать сумму нарастающим итогом (общую выручку) и прирост выручки (разницу между выручкой в текущий день и выручкой в предыдущий день, делённую на выручку в предыдущий день).

После того как составите запрос, попробуйте визуализировать результаты и постройте графики, отражающие динамику рассчитанных показателей.

### Решение:

Вариант 1

    SELECT
      t2.date,
      t2.revenue,
      SUM(t2.revenue) OVER(
        ORDER BY
          t2.date
      ) AS total_revenue,
      ROUND(
        (
          t2.revenue :: DECIMAL / LAG(t2.revenue, 1) OVER(
            ORDER BY
              t2.date
          ) - 1
        ) * 100,
        2
      ) AS revenue_change
    FROM
      (
        SELECT
          t1.date,
          SUM(p.price) AS revenue
        FROM
          (
            SELECT
              creation_time :: DATE AS date,
              UNNEST(product_ids) AS product_id
            FROM
              orders
            WHERE
              order_id NOT IN (
                SELECT
                  order_id
                FROM
                  user_actions
                WHERE
                  action = 'cancel_order'
              )
          ) t1
          LEFT JOIN products p ON p.product_id = t1.product_id
        GROUP BY
          t1.date
      ) t2
    ORDER BY
      t2.date

Вариант 2

    SELECT
      date,
      revenue,
      sum(revenue) OVER (
        ORDER BY
          date
      ) as total_revenue,
      round(
        100 * (
          revenue - lag(revenue, 1) OVER (
            ORDER BY
              date
          )
        ) :: decimal / lag(revenue, 1) OVER (
          ORDER BY
            date
        ),
        2
      ) as revenue_change
    FROM
      (
        SELECT
          creation_time :: date as date,
          sum(price) as revenue
        FROM
          (
            SELECT
              creation_time,
              unnest(product_ids) as product_id
            FROM
              orders
            WHERE
              order_id not in (
                SELECT
                  order_id
                FROM
                  user_actions
                WHERE
                  action = 'cancel_order'
              )
          ) t1
          LEFT JOIN products using (product_id)
        GROUP BY
          date
      ) t2

#### Замечание
Вариант запроса №2 от сервиса karpov, предлагается как верное решение. Его можно сократить, избыточность оконных функции стр. 10, достаточно сделать (revenue / пред. revenue - 1) * 100

### Визуализация

![визуализация 2_1_5](./img/2_2_1_vis.jpg)

Проанализируйте построенные графики и попробуйте ответить на следующие вопросы:

1. В какие дни наблюдалось заметное снижение ежедневной выручки? 
2. С чем это могло быть связано? (чтобы установить причину падения выручки, можете сопоставить текущие графики с графиками на дашборде из прошлого урока)

## Задание 2
Теперь на основе данных о выручке рассчитаем несколько относительных показателей, которые покажут, сколько в среднем потребители готовы платить за услуги нашего сервиса доставки. Остановимся на следующих метриках:

1. ARPU (Average Revenue Per User) — средняя выручка на одного пользователя за определённый период.
2. ARPPU (Average Revenue Per Paying User) — средняя выручка на одного платящего пользователя за определённый период.
3. AOV (Average Order Value) — средний чек, или отношение выручки за определённый период к общему количеству заказов за это же время.

Если за рассматриваемый период сервис заработал 100 000 рублей и при этом им пользовались 500 уникальных пользователей, из которых 400 сделали в общей сложности 650 заказов, тогда метрики будут иметь следующие значения:

ARPU =100000/500=200

ARPPU =100000/400=250

AOV=100000/650≈153,85

Задание

Для каждого дня в таблицах orders и user_actions рассчитайте следующие показатели:

1. Выручку на пользователя (ARPU) за текущий день.
2. Выручку на платящего пользователя (ARPPU) за текущий день.
3. Выручку с заказа, или средний чек (AOV) за текущий день.
4. Колонки с показателями назовите соответственно arpu, arppu, aov. Колонку с датами назовите date. 

При расчёте всех показателей округляйте значения до двух знаков после запятой.

Результат должен быть отсортирован по возрастанию даты. 

Поля в результирующей таблице: date, arpu, arppu, aov

**Пояснение:**

Будем считать, что оплата за заказ поступает сразу же после его оформления, т.е. случаи, когда заказ был оформлен в один день, а оплата получена на следующий, возникнуть не могут.

Платящими будем считать тех пользователей, которые в данный день оформили хотя бы один заказ, который в дальнейшем не был отменен.

При расчёте выручки помните, что не все заказы были оплачены — некоторые были отменены пользователями.

Не забывайте при делении заранее приводить значения к нужному типу данных.

**Подсказка на случай, если совсем не получается**

Для решения задачи необходимо сначала для каждого дня посчитать выручку, число всех пользователей, число платящих пользователей и число заказов. Затем необходимо объединить полученные таблицы и рассчитать все необходимые относительные показатели. Выручку мы уже считали в прошлом задании.

После того как составите запрос, попробуйте визуализировать результаты и постройте график, отражающий динамику рассчитанных показателей.

Решение:

Варианта 1

    WITH table_revenue AS (
      SELECT
        date,
        SUM(p.price) AS revenue,
        COUNT(DISTINCT ua.user_id) as users,
        COUNT(DISTINCT t1.order_id) AS count_orders
      FROM
        (
          SELECT
            creation_time :: DATE AS date,
            order_id,
            UNNEST(product_ids) AS product_id
          FROM
            orders
          WHERE
            order_id NOT IN (
              SELECT
                order_id
              FROM
                user_actions
              WHERE
                action = 'cancel_order'
            )
        ) t1
        LEFT JOIN products p ON p.product_id = t1.product_id
        LEFT JOIN user_actions ua ON ua.order_id = t1.order_id
      GROUP BY
        date
    ),
    all_users AS (
      SELECT
        time :: DATE as date,
        count(DISTINCT user_id) AS all_users
      FROM
        user_actions
      GROUP BY
        date
    )
    SELECT
      tr.date,
      ROUND(tr.revenue :: decimal / au.all_users, 2) AS arpu,
      ROUND(tr.revenue :: decimal / tr.users, 2) AS arppu,
      ROUND(tr.revenue :: decimal / tr.count_orders, 2) AS aov
    FROM
      table_revenue tr
      LEFT JOIN all_users au ON au.date = tr.date
    ORDER BY
      date

Вариант 2

    SELECT
      date,
      round(revenue :: decimal / users, 2) as arpu,
      round(revenue :: decimal / paying_users, 2) as arppu,
      round(revenue :: decimal / orders, 2) as aov
    FROM
      (
        SELECT
          creation_time :: date as date,
          count(distinct order_id) as orders,
          sum(price) as revenue
        FROM
          (
            SELECT
              order_id,
              creation_time,
              unnest(product_ids) as product_id
            FROM
              orders
            WHERE
              order_id not in (
                SELECT
                  order_id
                FROM
                  user_actions
                WHERE
                  action = 'cancel_order'
              )
          ) t1
          LEFT JOIN products using(product_id)
        GROUP BY
          date
      ) t2
      LEFT JOIN (
        SELECT
          time :: date as date,
          count(distinct user_id) as users
        FROM
          user_actions
        GROUP BY
          date
      ) t3 using (date)
      LEFT JOIN (
        SELECT
          time :: date as date,
          count(distinct user_id) as paying_users
        FROM
          user_actions
        WHERE
          order_id not in (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
        GROUP BY
          date
      ) t4 using (date)
    ORDER BY
      date

### Визуализация

![визуализация 2_1_5](./img/2_2_2_vis.jpg)

Проанализируйте построенный график и попробуйте ответить на следующие вопросы:

1. Какие метрики имеют больший разброс значений на протяжении рассматриваемого периода ?
2. Можно ли сказать, что отдельные метрики имеют аномально высокие или аномально низкие значения в отдельные дни ?
3. Какой вывод можно сделать о соотношении числа платящих пользователей и всех пользователей сервиса в рассматриваемые дни ?

## Задание 3
Дополним наш анализ ещё более интересными расчётами — вычислим все те же метрики, но для каждого дня будем учитывать накопленную выручку и все имеющиеся на текущий момент данные о числе пользователей и заказов. Таким образом, получим динамический ARPU, ARPPU и AOV и сможем проследить, как он менялся на протяжении времени с учётом поступающих нам данных.

По таблицам orders и user_actions для каждого дня рассчитайте следующие показатели:

1. Накопленную выручку на пользователя (Running ARPU).
2. Накопленную выручку на платящего пользователя (Running ARPPU).
3. Накопленную выручку с заказа, или средний чек (Running AOV).

Колонки с показателями назовите соответственно running_arpu, running_arppu, running_aov. Колонку с датами назовите date. 

При расчёте всех показателей округляйте значения до двух знаков после запятой.

Результат должен быть отсортирован по возрастанию даты. 

Поля в результирующей таблице: date, running_arpu, running_arppu, running_aov

**Пояснение:**

При расчёте числа пользователей и платящих пользователей на текущую дату учитывайте соответствующих пользователей за все предыдущие дни, включая текущий.

Платящими будем считать тех пользователей, которые на текущий день оформили хотя бы один заказ, который в дальнейшем не был отменен.

Будем считать, что оплата за заказ поступает сразу же после его оформления, т.е. случаи, когда заказ был оформлен в один день, а оплата получена на следующий, возникнуть не могут.

При расчёте выручки помните, что не все заказы были оплачены — некоторые были отменены пользователями.

Не забывайте при делении заранее приводить значения к нужному типу данных.

**Подсказка на случай, если совсем не получается**

Для решения этой задачи необходимо дополнить запрос из предыдущего задания и для каждого дня дополнительно рассчитать накопленную выручку, а также накопленное число всех пользователей и отдельно платящих пользователей. Для расчёта числа пользователей с накоплением потребуется информация о новых пользователях и новых платящих пользователях в каждый из рассматриваемых дней. Мы как раз считали это в одной из задач предыдущего урока.

После того как составите запрос, попробуйте визуализировать результаты и постройте график, отражающий динамику рассчитанных показателей.

### Решение:
Варианта 1

    with table_revenue as (
      SELECT
        date,
        sum(p.price) as revenue,
        COUNT(distinct ua.user_id) as users,
        COUNT(distinct t1.order_id) as count_orders
      FROM
        (
          SELECT
            creation_time :: date as date,
            order_id,
            unnest(product_ids) as product_id
          FROM
            orders
          WHERE
            order_id NOT in (
              SELECT
                order_id
              FROM
                user_actions
              WHERE
                action = 'cancel_order'
            )
        ) t1
        LEFT JOIN products p ON p.product_id = t1.product_id
        LEFT JOIN user_actions ua ON ua.order_id = t1.order_id
      GROUP BY
        date
    ),
    new_users_all AS (
      SELECT
        date,
        COUNT(DISTINCT user_id) AS count
      FROM
        (
          SELECT
            min(time) :: DATE AS date,
            user_id
          FROM
            user_actions
          GROUP BY
            user_id
        ) t1
      GROUP BY
        date
    ),
    new_users_payed AS (
      SELECT
        date,
        COUNT(DISTINCT user_id) AS count
      FROM
        (
          SELECT
            min(time) :: DATE AS date,
            user_id
          FROM
            user_actions
          WHERE
            order_id NOT in (
              SELECT
                order_id
              FROM
                user_actions
              WHERE
                action = 'cancel_order'
            )
          GROUP BY
            user_id
        ) t1
      GROUP BY
        date
    )
    SELECT
      tr.date,
      ROUND(
        SUM(tr.revenue) OVER(
          ORDER BY
            tr.date
        ) :: DECIMAL / SUM(nua.count) OVER(
          ORDER BY
            tr.date
        ),
        2
      ) AS running_arpu,
      ROUND(
        SUM(tr.revenue) OVER(
          ORDER BY
            tr.date
        ) :: DECIMAL / SUM(nup.count) OVER(
          ORDER BY
            tr.date
        ),
        2
      ) AS running_arppu,
      ROUND(
        SUM(tr.revenue) OVER(
          ORDER BY
            tr.date
        ) :: DECIMAL / SUM(tr.count_orders) OVER(
          ORDER BY
            tr.date
        ),
        2
      ) AS running_aov
    FROM
      table_revenue tr
      LEFT JOIN new_users_all nua ON nua.date = tr.date
      LEFT JOIN new_users_payed nup ON nup.date = tr.date
    ORDER BY
      date

Вариант 2

    SELECT
      date,
      round(
        sum(revenue) OVER (
          ORDER BY
            date
        ) :: decimal / sum(new_users) OVER (
          ORDER BY
            date
        ),
        2
      ) as running_arpu,
      round(
        sum(revenue) OVER (
          ORDER BY
            date
        ) :: decimal / sum(new_paying_users) OVER (
          ORDER BY
            date
        ),
        2
      ) as running_arppu,
      round(
        sum(revenue) OVER (
          ORDER BY
            date
        ) :: decimal / sum(orders) OVER (
          ORDER BY
            date
        ),
        2
      ) as running_aov
    FROM
      (
        SELECT
          creation_time :: date as date,
          count(distinct order_id) as orders,
          sum(price) as revenue
        FROM
          (
            SELECT
              order_id,
              creation_time,
              unnest(product_ids) as product_id
            FROM
              orders
            WHERE
              order_id not in (
                SELECT
                  order_id
                FROM
                  user_actions
                WHERE
                  action = 'cancel_order'
              )
          ) t1
          LEFT JOIN products using(product_id)
        GROUP BY
          date
      ) t2
      LEFT JOIN (
        SELECT
          time :: date as date,
          count(distinct user_id) as users
        FROM
          user_actions
        GROUP BY
          date
      ) t3 using (date)
      LEFT JOIN (
        SELECT
          time :: date as date,
          count(distinct user_id) as paying_users
        FROM
          user_actions
        WHERE
          order_id not in (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
        GROUP BY
          date
      ) t4 using (date)
      LEFT JOIN (
        SELECT
          date,
          count(user_id) as new_users
        FROM
          (
            SELECT
              user_id,
              min(time :: date) as date
            FROM
              user_actions
            GROUP BY
              user_id
          ) t5
        GROUP BY
          date
      ) t6 using (date)
      LEFT JOIN (
        SELECT
          date,
          count(user_id) as new_paying_users
        FROM
          (
            SELECT
              user_id,
              min(time :: date) as date
            FROM
              user_actions
            WHERE
              order_id not in (
                SELECT
                  order_id
                FROM
                  user_actions
                WHERE
                  action = 'cancel_order'
              )
            GROUP BY
              user_id
          ) t7
        GROUP BY
          date
      ) t8 using (date)

### Визуализация

![визуализация 2_2_3](./img/2_2_3_vis.jpg)

Проанализируйте построенный график и попробуйте ответить на следующие вопросы:

1. Какая в целом динамика у рассчитанных метрик? Они растут, падают или имеют примерно одинаковое значение в каждый из дней ?
2. Можно ли, учитывая динамику рассчитанных метрик, предположить, что со временем растёт число заказов на одного пользователя ?

## Задание 4

Для каждого дня недели в таблицах orders и user_actions рассчитайте следующие показатели:

Выручку на пользователя (ARPU).
Выручку на платящего пользователя (ARPPU).
Выручку на заказ (AOV).
При расчётах учитывайте данные только за период с 26 августа 2022 года по 8 сентября 2022 года включительно — так, чтобы в анализ попало одинаковое количество всех дней недели (ровно по два дня).

В результирующую таблицу включите как наименования дней недели (например, Monday), так и порядковый номер дня недели (от 1 до 7, где 1 — это Monday, 7 — это Sunday).

Колонки с показателями назовите соответственно arpu, arppu, aov. Колонку с наименованием дня недели назовите weekday, а колонку с порядковым номером дня недели weekday_number.

При расчёте всех показателей округляйте значения до двух знаков после запятой.

Результат должен быть отсортирован по возрастанию порядкового номера дня недели.

Поля в результирующей таблице: 

weekday, weekday_number, arpu, arppu, aov

Пояснение: 

Будем считать, что оплата за заказ поступает сразу же после его оформления, т.е. случаи, когда заказ был оформлен в один день, а оплата получена на следующий, возникнуть не могут.

Платящими будем считать тех пользователей, которые в данный день оформили хотя бы один заказ, который в дальнейшем не был отменен.

При расчёте выручки помните, что не все заказы были оплачены — некоторые были отменены пользователями.

Не забывайте при делении заранее приводить значения к нужному типу данных.

В этой задаче порядковый номер дня недели необходим для того, чтобы дни недели были расположены на графике слева направо в правильном порядке — не по возрастанию наименования, а по возрастанию порядкового номера. Для получения корректной визуализации в настройках оси X необходимо отключить сортировку, установленную по умолчанию.

### Решение:

Вариант 1

    SELECT
      weekday,
      t1.weekday_number as weekday_number,
      round(revenue :: decimal / users, 2) as arpu,
      round(revenue :: decimal / paying_users, 2) as arppu,
      round(revenue :: decimal / orders, 2) as aov
    FROM
      (
        SELECT
          to_char(creation_time, 'Day') as weekday,
          max(date_part('isodow', creation_time)) as weekday_number,
          count(distinct order_id) as orders,
          sum(price) as revenue
        FROM
          (
            SELECT
              order_id,
              creation_time,
              unnest(product_ids) as product_id
            FROM
              orders
            WHERE
              order_id not in (
                SELECT
                  order_id
                FROM
                  user_actions
                WHERE
                  action = 'cancel_order'
              )
              and creation_time >= '2022-08-26'
              and creation_time < '2022-09-09'
          ) t4
          LEFT JOIN products using(product_id)
        GROUP BY
          weekday
      ) t1
      LEFT JOIN (
        SELECT
          to_char(time, 'Day') as weekday,
          max(date_part('isodow', time)) as weekday_number,
          count(distinct user_id) as users
        FROM
          user_actions
        WHERE
          time >= '2022-08-26'
          and time < '2022-09-09'
        GROUP BY
          weekday
      ) t2 using (weekday)
      LEFT JOIN (
        SELECT
          to_char(time, 'Day') as weekday,
          max(date_part('isodow', time)) as weekday_number,
          count(distinct user_id) as paying_users
        FROM
          user_actions
        WHERE
          order_id not in (
            SELECT
              order_id
            FROM
              user_actions
            WHERE
              action = 'cancel_order'
          )
          and time >= '2022-08-26'
          and time < '2022-09-09'
        GROUP BY
          weekday
      ) t3 using (weekday)
    ORDER BY
      weekday_number

Вариант 2
