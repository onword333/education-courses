# Алгоритмы
## Возможноые задачи на собеседовании
- есть бинарный вектор, необходимо определить максимальную длину последовательноси идущих друг за другом единиц [пример](https://youtu.be/0yxjWwoZtLw?t=89)
- задача об анограммах [пример](https://youtu.be/zU-LndSG5RE?t=18)
- правильные скобочные последовательности [пример](https://youtu.be/zU-LndSG5RE?t=500)

## Минимальный прямоугольник
На клетчатой плоскости закрашено K клеток. Требуется найти минимальный по площади прямоугольник, со сторонами, параллельными линиям сетки, покрывающий все закрашенные клетки.

Формат ввода:

Во входном файле, на первой строке, находится число K (1 ≤ K ≤ 100). На следующих K строках находятся пары чисел Xi и Yi — координаты закрашенных клеток (|Xi|, |Yi| ≤ 109).

Формат вывода:

Выведите в выходной файл координаты левого нижнего и правого верхнего углов прямоугольника.

Пример:

    Ввод    Вывод
    4       1 1 6 5
    1 3
    3 1
    3 5
    6 3

### Решение
```python
def min_rectangle(k, points):
  """
  Находит минимальный прямоугольник, покрывающий все закрашенные клетки.

  Args:
    k: Количество закрашенных клеток.
    points: Список пар чисел (x, y) - координаты закрашенных клеток.

  Returns:
    Список из 4 чисел: (x1, y1, x2, y2) - координаты левого нижнего и 
    правого верхнего углов прямоугольника.
  """

  # Находим минимальные и максимальные координаты по X и Y.
  min_x = min(point[0] for point in points)
  max_x = max(point[0] for point in points)
  min_y = min(point[1] for point in points)
  max_y = max(point[1] for point in points)

  # Возвращаем координаты прямоугольника.
  return min_x, min_y, max_x, max_y

# Считываем данные из входного файла.
with open("input.txt", "r") as f:
  k = int(f.readline())
  points = [list(map(int, line.split())) for line in f]

# Находим минимальный прямоугольник.
result = min_rectangle(k, points)

# Записываем результат в выходной файл.
with open("output.txt", "w") as f:
  f.write(" ".join(map(str, result)))
```

Визуально это можно представить так:
![минимальные прямоугольник](./assets/min_rectagnle.png)

*P.S. Правда мне понятно почему задача называется мининальный прямоугольник, при этом мы находим координаты самого большого прямоугольника.*

## Петя, Маша и верёвочки
На столе лежали две одинаковые верёвочки целой положительной длины.

Петя разрезал одну из верёвочек на N частей, каждая из которых имеет целую положительную длину, так что на столе стало N+1 верёвочек. Затем в комнату зашла Маша и взяла одну из лежащих на столе верёвочек. По длинам оставшихся на столе N верёвочек определите, какую наименьшую длину может иметь верёвочка, взятая Машей.

Формат ввода:

Первая строка входных данных содержит одно целое число N — количество верёвочек, оставшихся на столе (2 ≤ N ≤ 1000). Во второй строке содержится N целых чисел li — длины верёвочек (1 ≤ li ≤ 1000).

Формат вывода:

Выведите одно целое число — наименьшую длину, которую может иметь верёвочка, взятая Машей.

Пример 1:

    ввод      вывод
    4         1
    1 5 2 1

Пример 2:

    ввод      вывод
    4         24
    5 12 4 3

### Решение
```python
def missing_rope(lengths):
  
  # Сумма длин всех веревок
  total_length = sum(lengths)
  
  missing_rope_length = total_length

  for v in lengths:
    sum_other = total_length - v
    if v > sum_other:
      # найдена полная веревка, вычисляем разницу
      # и прекращаем цикл
      missing_rope_length = v - sum_other
      break

  return missing_rope_length

# Считываем данные из входного файла.
with open("input.txt", "r") as f:
  k = int(f.readline())
  points = list(map(int, f.readline().split()))

# Находим минимальный прямоугольник.
print(missing_rope(points))
```

## Продавец рыбы
Вася решил заняться торговлей рыбой. С помощью методов машинного обучения он предсказал цены на рыбу на N дней вперёд. Он решил, что в один день он купит рыбу, а в один из следующих дней — продаст (то есть совершит или ровно одну покупку и продажу или вообще не совершит покупок и продаж, если это не принесёт ему прибыли). К сожалению, рыба — товар скоропортящийся и разница между номером дня продажи и номером дня покупки не должна превышать K.

Определите, какую максимальную прибыль получит Вася.

Формат ввода:

В первой строке входных данных задаются числа N и K (1 ≤ N ≤ 10000, 1 ≤ K ≤ 100).

Во второй строке задаются цены на рыбу в каждый из N дней. Цена — целое число, которое может находится в пределах от 1 до 10^9.

Формат вывода:

Выведите одно число — максимальную прибыль, которую получит Вася


Пример 1:

    ввод        вывод
    5 2         2
    1 2 3 4 5

Пример 2:

    ввод        вывод
    5 2         0
    5 4 3 2 1

### Решение

```python
def max_revenue(N, K, prices):
  max_profit = 0

  # 1 2 3 4 5
  for buy_day in range(N):
    for sell_day in range(buy_day + 1, min(N, buy_day + K + 1)):    
      profit = prices[sell_day] - prices[buy_day]
      if (profit > max_profit):
        max_profit = profit
  
  return max_profit

# Считываем данные из входного файла.
with open("input.txt", "r") as f:
  N, K = map(int, f.readline().split())
  prices = list(map(int, f.readline().split()))  

# Вызываем функцию и выводим результат
print(max_revenue(N, K, prices))
```

## Шахматная доска
Из шахматной доски по границам клеток выпилили связную (не распадающуюся на части) фигуру без дыр. Требуется определить ее периметр.

Формат ввода:

Сначала вводится число N (1 ≤ N ≤ 64) – количество выпиленных клеток. В следующих N строках вводятся координаты выпиленных клеток, разделенные пробелом (номер строки и столбца – числа от 1 до 8). Каждая выпиленная клетка указывается один раз.

Формат вывода:

Выведите одно число – периметр выпиленной фигуры (сторона клетки равна единице).

Пример 1
    
    ввод    вывод
    3       8
    1 1
    1 2
    2 1

Пример 2

    ввод    вывод
    1       4
    8 8

### Решение

```python
def calculate_perimeter(N, cells):
  perimeter = 0
  for i in range(N):
    row, col = cells[i]
    # Проверяем клетки вокруг текущей клетки
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
      nr, nc = row + dr, col + dc
      # Если клетка вне границы или пустая, увеличиваем периметр
      if nr < 1 or nr > 8 or nc < 1 or nc > 8 or (nr, nc) not in cells:
        perimeter += 1
  return perimeter

cells = []

# Считываем данные из входного файла.
with open("input.txt", "r") as f:
  N = int(f.readline())

  for line in f:
    val = map(int, line.split())
    cells.append(tuple(list(val)))  

# Вызываем функцию и выводим результат
print(calculate_perimeter(N, cells))
```

## Амбициозная улитка
Домашний питомец мальчика Васи — улитка Петя. Петя обитает на бесконечном в обе стороны вертикальном столбе, который для удобства можно представить как числовую прямую. Изначально Петя находится в точке 0.

Вася кормит Петю ягодами. У него есть n ягод, каждая в единственном экземпляре. Вася знает, что если утром он даст Пете ягоду с номером i, то поев и набравшись сил, за остаток дня Петя поднимется на ai единиц вверх по столбу, но при этом за ночь, потяжелев, съедет на bi единиц вниз. Параметры различных ягод могут совпадать. 

Пете стало интересно, а как оно там, наверху, и Вася взялся ему в этом помочь. Ближайшие n дней он будет кормить Петю ягодами из своего запаса таким образом, чтобы максимальная высота, на которой побывал Петя за эти n дней была максимальной. К сожалению, Вася не умеет программировать, поэтому он попросил вас о помощи. Найдите, максимальную высоту, на которой Петя сможет побывать за эти n дней и в каком порядке Вася должен давать Пете ягоды, чтобы Петя смог её достичь!

Формат ввода:

В первой строке входных данных дано число n(1 ≤ n ≤ 5*10^5) — количество ягод у Васи. В последующих n строках описываются параметры каждой ягоды. 
В i + 1 строке дано два числа ai и bi (0 ≤ ai, bi ≤ 10^9) — то, насколько поднимется улитка за день после того, как съест i ягоду и насколько опуститься за ночь.

Формат вывода:
В первой строке выходных данных выведите единственное число — максимальную высоту, которую сможет достичь Петя, если Вася будет его кормить оптимальным образом. В следующей строке выведите n различных целых чисел от  1 до n — порядок, в котором Вася должен кормить Петю (i число в строке соответствует номеру ягоды, которую Вася должен дать Пете в i день чтобы Петя смог достичь максимальной высоты).

Пример 1:

    3     10
    1 5   2 3 1
    8 2
    4 4

Пример 2:

    2     10
    7 6   2 1
    7 4

Примечания:

Во втором примере изначально улитка находится на высоте 0. Пусть сначала Петя накормит её второй ягодой, а затем первой. После того как она съест вторую ягоду, за день она поднимется на 7 (и окажется на высоте 7), а за ночь опустится на 4 (и окажется на высоте 3). После того как она съест первую ягоду, за день она поднимется на 7 (и окажется на высоте 10), а за ночь опустится на 6 (и окажется на высоте 4).

Таким образом, максимальная высота, на которой побывает улитка при данном порядке кормления, равна 10. Нетрудно видеть, что если Петя накормит улитку сначала первой ягодой, а затем второй, то максимальная высота, на которой побывает улитка, будет меньше.

### Решение
```python
# будут две группы
# положительные и отрицательные ягоды
pos, neg = [], []

max_down = 0
max_down_berr = (0, 0, 0, 0)

max_up = 0
max_up_berr = (0, 0, 0, 0)

max_height = 0
feeding_order = []
current_height = 0

# Считываем данные из входного файла.
with open("input.txt", "r") as f:
  n = int(f.readline())
  
  i = 0
  for line in f:
    i += 1
    a, b = map(int, line.split())

    ber = (a, b, i, a - b)

    if ber[0] >= ber[1]:
      pos.append(ber)
      if ber[1] > max_down:
        max_down = ber[1]
        max_down_berr = ber
    else:
      neg.append(ber)
      if ber[0] > max_up:
        max_up = ber[0]
        max_up_berr = ber

# ягоду, которая максимально спускает
# улитку - перемещаем в конец списка
if len(pos) > 0:
  ind = pos.index(max_down_berr)
  pos.append(pos.pop(ind))

# ягоду, которая максимально поднимает
# улитку - перемещаем в начало
if len(neg) > 0:
  ind = neg.index(max_up_berr)
  neg.pop(ind)
  neg.insert(0, max_up_berr)

berries = pos + neg

for berr in berries:
  current_height += berr[0]      # Увеличиваем высоту за день
  if current_height > max_height:
    max_height = current_height

  current_height -= berr[1]      # уменьшаем высоту за день
  feeding_order.append(berr[2])  # заполняем схему кормления

print(max_height)
print(*feeding_order)
```